## Общее описание решения

В данном репозитории есть три ветки:

1.[master](https://github.com/tinunadno/test_task/tree/master) - решение с большим упором на структуру и расширяемость

2.[cool_mode_for_console](https://github.com/tinunadno/test_task/tree/cool_mode_for_console) - то-же решение, что и в master, но с более комплексным консольным интерфейсом

3.simple_solution_branch - максимально простое и последовательное решение, где реализация максимально соответствует ТЗ

В этой ветке я специально сделал такое решение, которое будет максимально простое для восприятия, обработка происходит в три этапа:

1.[чтение](https://github.com/tinunadno/test_task/blob/simple_solution_branch/map_processing/IO/file_reader.cpp)

2.[парсинг](https://github.com/tinunadno/test_task/blob/simple_solution_branch/map_processing/grid_processing/grid_tracer.cpp)

3.[взаимодействие с пользователем](https://github.com/tinunadno/test_task/blob/simple_solution_branch/map_processing/UI/console_interface.cpp)

При этом все выполнено максимально приближенно к ТЗ

## Описание решения

В этом разделе будет описан только алгоритм решения без углубления в реализацию этого алгоритма, так как кода тут не много

После прочтения файла линейный массив из uint8_t передается в функцию парсинга

В ней я последовательно бегу по *карте* и проверяю клетку на принадлежность к множеству объектов

Если натыкаюсь на 2, то просто добавляю его в rtree, реализация которого была взята из библиотеки boost (что бы использовать отлаженное и оптимизированное решение, и не делать самому :D)
если же натыкаюсь на 1, то сначала проверяю, что сверху нету 1 (это бы означало, что этот объект уже был обработан), затем завожу два новых счетчика, и бегу сначала до нижнего края объекта
а потом до правого и смещаю счетчик по x, таким образом я вычисляю размер объекта, и могу вычислить его центр, и всю эту информацию я добавляю в vector

Когда файл распаршен и у меня есть дерево для объектов второго типа и вектор для объектов первого типа, я инициализирую unordered_map ключем которого является индекс второго объекта,
 а значением pair<vector<индекс объекта первого типа, расстояние до соответствующему ему объекту второго типа>, булевое значение (был ли этот вектор отсортирован, понадобится позже)>

Затем я последовательно иду по вектору и получаю ближайшие объекты второго типа из rtree, вычисляю расстояние между ними и добавляю в unordered_map

После того, как исходные данные были преобразованы в unordered_map<--//--> он передается в функцию *пользовательского интерфейса*, где при запросе станции соответствующий ей вектор сортируется, если булевое значение в паре - false
и выводится в консоль.

### Асимптотика

Пусть количество объектов первого типа - N, второго - M, замер поля X на Y

Тогда Парсинг файла в rtree и vector будет O(X*Y + M*log(M))

Преобразование в unordered_map<--//--> будет O(N*log(M))

И сортировка соответствующего вектора - O(K*B*log(B)), где K - количество запросов, а B - кол-во обьектов первого типа в соответствующем векторе, в худшем случае O(K*B*log(B))
*при этом стоит учитывать, что K - не всегда равно M, и для отдельного запроса вектора скорее всего будут меньше, чем N, так что это - не худшее решение*

*Также стоит отметить, что для маленьких N M возможно решение за O(N*M + X*Y + K*log(B)) будет эффективней и для этого можно написать небольшой dispatcher, который будет выбирать нужнок
решение в зависимости от ВД, но это бы усложнило код, а в этой ветке я пытался сделать его максимально последовательным*

Итоговая асимптотика O(X*Y + N*log(M) + K*B*log(B))

### Сложность по памяти

Пусть количество объектов первого типа - N, второго - M, замер поля X на Y

Хранение карты - O(X*Y)

Хранение объектов перед преобразованием - O(N + M)

хранение unordered_map<--//--> - O(N + M)

и тогда сложность такого решения по памяти составит O(X*Y + R), где R = max(N, M)

### Пример работы

![example](content/example.gif) 